\documentclass[a4paper]{ctexart}


\newcommand{\customhrule}{
    \vspace{0.1cm}
    \noindent\rule{\linewidth}{0.5pt}
    % \vspace{0.1cm}
}

\usepackage{geometry}
\geometry{
    top=2.5cm,
    bottom=2.5cm,
    left=2.5cm,
    right=2.5cm
}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{hyperref}

% 设置代码字体为 Code New Roman Nerd Font
\setmonofont{CodeNewRoman Nerd Font}

% 超链接样式配置
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

% 定义 Rust 语言
\lstdefinelanguage{Rust}{
    keywords={as, break, const, continue, crate, else, enum, extern, false, fn, for, if, impl, in, let, loop, match, mod, move, mut, pub, ref, return, self, Self, static, struct, super, trait, true, type, unsafe, use, where, while, async, await, dyn},
    keywordstyle=\color{blue}\bfseries,
    ndkeywords={bool, u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, f32, f64, usize, isize, str, char, Box, Vec, String, Option, Result},
    ndkeywordstyle=\color{purple}\bfseries,
    sensitive=true,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    morestring=[b]",
    morestring=[b]'
}

% 代码块样式
\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,        % 关键字：蓝色粗体
    commentstyle=\color{gray}\itshape,         % 注释：灰色斜体
    stringstyle=\color{red},                   % 字符串：红色
    numberstyle=\tiny\color{gray},             % 行号：灰色
    identifierstyle=\color{black},             % 标识符：黑色
    backgroundcolor=\color{gray!10},           % 背景色
    frame=single,
    xleftmargin=2em,
    framexleftmargin=1.5em,
    breaklines=true,
    showstringspaces=false                     % 不显示字符串中的空格
}

\begin{document}

\title{ch1-应用程序与基本执行环境}
\author{odlove}
\date{\today}
\maketitle

\section{Introduction}

本章的最终任务是完成一个基于
\href{https://github.com/rustsbi/rustsbi}{RustSBI}
服务和
\href{https://www.qemu.org/}{QEMU}
完成输出 Hello, world 并关机.

\section{Content}

\subsection{第一步: 创建一个裸机程序}

\subsubsection{1. 一个空程序}

创建工作目录
\begin{lstlisting}[language=bash]
$ mkdir rCore
$ cd rCore
$ cargo new os
$ cd os
\end{lstlisting}

此时我们的工作目录已经创建完成,
运行
\begin{lstlisting}
$ cargo run
\end{lstlisting}
可以看到输出的 ``Hello, world!".

但是我们的目标是编译到 riscv 的裸机环境,
cargo 使用 \verb|--target| 来指定编译目标,
所以让我们运行
\begin{lstlisting}[language=bash]
$ cargo build --target riscv64gc-unknown-none-elf
\end{lstlisting}

运行后会看到如下错误输出：
\begin{lstlisting}
error[E0463]: can't find crate for `std`
  |
  = note: the `riscv64gc-unknown-none-elf` target may not support the standard library
  = note: `std` is required by `os` because it does not declare `#![no_std]`

error: cannot find macro `println` in this scope
 --> src/main.rs:2:5
  |
2 |     println!("Hello, world!");
  |     ^^^^^^^

error: `#[panic_handler]` function required, but not found

For more information about this error, try `rustc --explain E0463`.
error: could not compile `os` (bin "os") due to 3 previous errors
\end{lstlisting}

这里有三个错误:
\begin{enumerate}
    \item{找不到标准库}
        \begin{lstlisting}
error[E0463]: can't find crate for `std`
  |
  = note: the `riscv64gc-unknown-none-elf` target may not support the standard library
  = note: `std` is required by `os` because it does not declare `#![no_std]`
        \end{lstlisting}
        这是因为我们使用的是裸机环境,
        std 库是操作系统之上的一层抽象,
        依赖于操作系统.
    \item{找不到 \verb|println| 宏}
        \begin{lstlisting}
error: cannot find macro `println` in this scope
 --> src/main.rs:2:5
  |
2 |     println!("Hello, world!");
  |     ^^^^^^^
        \end{lstlisting}
        println 宏来自于 std 库,
        没有 std 库自然就没有 println 宏
    \item 缺少 \verb|#[panic_handler]|
        \begin{lstlisting}
error: `#[panic_handler]` function required, but not found
        \end{lstlisting}
        \verb|#[panic_handler]| 负责在rust程序崩溃时进行处理,
        一般情况下 std 库会提供, 但是我们没有 std 库.
        这是 rust 语言本身的要求, 参见
        \href{https://doc.rust-lang.org/reference/panic.html\#the-panic\_handler-attribute}{Rust Reference}
        和
        \href{https://docs.rust-embedded.org/book/start/panicking.html}{Embedded Rust Book}.
\end{enumerate}

在解决这些问题之前, 让我们使用一个小小的 trick:
在当前目录下创建 \verb|.cargo/config.toml| 文件, 内容如下:
\begin{lstlisting}
[build]
target = "riscv64gc-unknown-none-elf"
\end{lstlisting}
这将会更改 \verb|cargo| 的默认目标,
我们就不需要每次在命令后添加
\texttt{-{}-target riscv64gc-unknown-none-elf} 了.

\verb|println| 宏的问题最好解决, 只要直接删除就好了.
标准库的问题则是要在程序开头添加 \verb|#![no_std]|.
而\verb|#[panic_handler]|则需要我们添加一个函数:
\begin{lstlisting}[language=Rust]
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
\end{lstlisting}

再次编译, 又遇到了新的错误:
\begin{lstlisting}
error: using `fn main` requires the standard library
  |
  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`

error: could not compile `os` (bin "os") due to 1 previous error
\end{lstlisting}
这是因为 \verb|main| 函数的环境也是由 std 库提供的.
现在我们需要添加 \verb|#![no_main]| 并删除 \verb|main| 函数.

此时的 \verb|main.rs| 内容如下:
\begin{lstlisting}[language=rust]
#![no_std]
#![no_main]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
\end{lstlisting}

此时运行 \verb|cargo build|, 我们终于编译成功了.

让我们来看看此时编译得到的可执行文件:
\begin{lstlisting}[language=bash]
$ file target/riscv64gc-unknown-none-elf/debug/os
\end{lstlisting}
得到:
\begin{lstlisting}
target/riscv64gc-unknown-none-elf/debug/os: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, with debug_info, not stripped
\end{lstlisting}
\verb|ELF 64-bit|: 64位ELF格式\\
\verb|LSB|: Little-Endian（小端序）\\
\verb|UCB RISC-V|: RISC-V架构\\
\verb|RVC|: 支持压缩指令集（C扩展）\\
\verb|double-float ABI|: 双精度浮点\\
\verb|statically linked|: 静态链接\\
\verb|with debug_info|: 包含调试信息\\
\verb|not stripped|: 符号表还在

运行
\begin{lstlisting}
$ rust-objdump -h target/riscv64gc-unknown-none-elf/debug/os
\end{lstlisting}
得到
\begin{lstlisting}
target/riscv64gc-unknown-none-elf/debug/os:     file format elf64-littleriscv

Sections:
Idx Name              Size     VMA              Type
  0                   00000000 0000000000000000
  1 .debug_abbrev     00000106 0000000000000000 DEBUG
  2 .debug_info       000005a9 0000000000000000 DEBUG
  3 .debug_aranges    00000030 0000000000000000 DEBUG
  4 .debug_str        0000047b 0000000000000000 DEBUG
  5 .comment          0000008b 0000000000000000
  6 .riscv.attributes 00000066 0000000000000000
  7 .debug_frame      00000038 0000000000000000 DEBUG
  8 .debug_line       00000048 0000000000000000 DEBUG
  9 .symtab           00000138 0000000000000000
 10 .shstrtab         00000083 0000000000000000
 11 .strtab           00000051 0000000000000000
\end{lstlisting}
\verb|objdump -h| 是查看 Section Headers 的命令.

此处需要注意的是这个 elf 文件没有
\verb|.text| \verb|.rodata| \verb|.data| \verb|.bss| 段,
这说明目前我们的程序是一个空程序.
并且所有的 VMA 都为 0,
这表明链接器不知道这个程序应该被加载到内存的什么地址.
在裸机环境中, 我们需要通过链接脚本(linker script)来告诉链接器
代码和数据应该放在内存的哪个位置.

\subsubsection{2. 一个裸机程序}

既然当前我们的空程序编译成功了,
那么接下来就是要给它添加一些内容了.

首先, 让我们添加一个最简单的空循环
\begin{lstlisting}[language=rust]
#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    loop {}
}
\end{lstlisting}
这里, \verb|_start|
是链接器默认的程序启动处的入口符号.

编译完成后, 我们可以查看一下得到的可执行文件:
\begin{lstlisting}[language=bash]
$ rust-objdump -d target/riscv64gc-unknown-none-elf/debug/os
\end{lstlisting}
可以看到
\begin{lstlisting}
target/riscv64gc-unknown-none-elf/debug/os:     file format elf64-littleriscv

Disassembly of section .text:

0000000000011158 <_start>:
   11158: a009          j       0x1115a <_start+0x2>
   1115a: a001          j       0x1115a <_start+0x2>
\end{lstlisting}
这里是两个压缩指令, 我们暂时不去深入,
只要知道是一个死循环就可以了.

编译完成后我们就可以通过如下命令使用 qemu 执行程序了:
\begin{lstlisting}[language=bash]
$ qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios none \
    -kernel target/riscv64gc-unknown-none-elf/debug/os
\end{lstlisting}
运行后在笔者的电脑上可以看到 qemu 跑满了一个核心,
没有任何输出信息.
我们可以先按 Ctrl-a 然后按 x 退出.

那么又有一个问题来了,
我们怎么知道程序是否在正常运行呢,
这就需要 debugger 的帮助了.
而 qemu 内置了这一功能.
运行以下命令来启用 gdb 远程调试,
参数具体含义请查看 man 手册.
\begin{lstlisting}[language=bash]
$ qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios none \
    -kernel target/riscv64gc-unknown-none-elf/debug/os \
    -S -s
\end{lstlisting}

然后运行以下 gdb 命令连接 qemu 进行调试:
\begin{lstlisting}[language=bash]
$ riscv64-linux-gnu-gdb \
    -ex 'file target/riscv64gc-unknown-none-elf/debug/os' \
    -ex 'target remote localhost:1234'
\end{lstlisting}
这里的 \verb|-ex| 参数会在 gdb 启动后自动执行指定的命令,
等价于在 gdb 交互提示符 \verb|(gdb)| 下手动输入这些命令.
这里的 file 指令是让 gdb 加载符号表,
我们就可以使用它的符号了.

我们先看看此时我们的程序:
\begin{lstlisting}
(gdb) x/10i _start
   0x11158 <os::_start>:        Cannot access memory at address 0x11158
\end{lstlisting}
这里的 \verb|x/10i| 表示查看内存,
以指令形式显示(反汇编), 重复10次.
这里的结果表示似乎出了些问题.
让我们继续使用 si 运行,
可以看到在运行几条指令后 pc 跳转到了
0x80000000, 此时再查看当前的指令,
可以看到:
\begin{lstlisting}
(gdb) x/5i $pc
=> 0x80000000:  unimp
   0x80000002:  unimp
   0x80000004:  unimp
   0x80000006:  unimp
   0x80000008:  unimp
\end{lstlisting}
这里的 unimp 是 unimplemented 的缩写,
表示未实现或非法指令.
我们运行到这里的时候就会卡死, 运行不到下一条指令.

\begin{quote}
{\itshape
这一部分笔者暂时没有查到相关文档,
只是作为参考. 目前这一部分对于我们也不是非常重要.

这可能是因为非法指令会触发非法指令异常(illegal
instruction exception),
CPU 会跳转到异常向量表中对应的处理程序地址.
但是很明显我们没有初始化过异常向量表,
于是跳转之后还是一条非法指令, 于是再次跳转,
就这样卡死在这里.
}
\end{quote}

那么如何让程序加载到 0x80000000 呢,
这时候就到链接脚本出场的时候了.
qemu 会解析 elf 文件来获取代码加载的信息,
当前我们的 elf 文件中的地址是一个非法地址,
不能被正确加载.

链接脚本如下:
\begin{lstlisting}
OUTPUT_ARCH(riscv)
ENTRY(_start)

SECTIONS {
    . = 0x80000000;
    .text   : { *(.text*) }
    .rodata : { *(.rodata*) }
    .data   : { *(.data*) }
    .bss    : { *(.bss*) *(COMMON) }
}
\end{lstlisting}
我们将它保存为 \verb|src/linker.ld|.

链接脚本的含义如下:
\begin{lstlisting}
OUTPUT_ARCH(riscv)
\end{lstlisting}
表示输出的目标架构为 riscv, 可以省略.
如果省略, 链接器会根据 rustc 传入的参数确定目标架构.

\

\begin{lstlisting}
ENTRY(_start)
\end{lstlisting}
表示指定程序从符号 \verb|_start| 开始运行.
但实际上是通过将 elf 文件的 \verb|e_entry| 字段设置成
\verb|_start| 的地址实现的,
如果我们后面直接使用 bin 文件,
elf 的信息会被删除,
这一条对我们是没有用的.

\

\begin{lstlisting}
SECTIONS {
    . = 0x80000000;
    .text   : { *(.text*) }
    .rodata : { *(.rodata*) }
    .data   : { *(.data*) }
    .bss    : { *(.bss*) *(COMMON) }
}
\end{lstlisting}
这里 SECTIONS 中的第一行指明装载地址为0x80000000,
后面的段从这个地址开始依次排列.
后面的部分中, 冒号左边表示的是生成在可执行文件中的段名,
右边表示的是这个段需要装载的内容.
例如 \verb|*(.text*)| 中, 括号外面的 \verb|*| 表示
匹配所有文件, 而括号里面的 \verb|.text*| 则表示
匹配所有段名以 \verb|.text| 开始的段,
合起来就是匹配所有文件中所有以 \verb|.text| 开始的段.
如果使用的是 bin 文件, 生成的段名信息也会被丢弃.

我们尝试编译:
\begin{lstlisting}
$ cargo rustc -- -C link-arg=-Tsrc/linker.ld
\end{lstlisting}
可以看到编译成功.

这里的 cargo rustc 命令表示将 \verb|--| 后的参数
传给编译器, 这里参数的含义就是指定链接脚本.

同样的, 我们可以将这个参数写入 \verb|.cargo/config.toml|,
故目前的 \verb|.cargo/config.toml| 内容如下:
\begin{lstlisting}
[build]
target = "riscv64gc-unknown-none-elf"

[target.riscv64gc-unknown-none-elf]
rustflags = ["-C", "link-arg=-Tsrc/linker.ld"]
\end{lstlisting}

接下来运行到重新运行,
在gdb调试中就可以看到 loop 的汇编代码了
\begin{lstlisting}
(gdb) x/5i 0x80000000
   0x80000000 <os::_start>:     j       0x80000002 <os::_start+2>
=> 0x80000002 <os::_start+2>:   j       0x80000002 <os::_start+2>
   0x80000004:  unimp
   0x80000006:  unimp
   0x80000008:  unimp
\end{lstlisting}

\subsubsection{3. RustSBI}
既然我们已经可以将编译出的指令放入 qemu 中执行,
那么理论上我们就具备了在 qemu 中实现任意功能的能力了.

不过要我们手动控制底层硬件还是太过麻烦了,
在设计之初 riscv 就提供了
\href{https://github.com/riscv-non-isa/riscv-sbi-doc}
{SBI(Supervisor Binary Interface) 规范},
为操作系统内核提供了一层硬件层的抽象.

SBI 定义了操作系统(运行在 Supervisor 特权级)
与底层固件(运行在 Machine 特权级)之间的接口规范.
底层固件负责处理硬件相关的细节(如串口、时钟、电源管理等),
并向上层操作系统提供标准化的服务接口.
操作系统只需要按照 SBI 规范调用这些接口,
就能完成硬件操作, 而无需关心具体的硬件细节.

RustSBI 则是 SBI 规范的一个 Rust 实现.

这里有一个有趣的地方:
SBI 指的实际上是接口规范,
而实际的提供接口服务的软件其实叫做
SBI implementation 或者
Supervisor Execution Environment(SEE).

好了, 那么我们就开始探索 SBI 吧.

qemu 版本的预编译 RustSBI 可以在\href{https://github.com/rustsbi/rustsbi-qemu/releases}{这里}下载到,
可以看到这个项目目前已经 archived 了,
这是因为他们现在使用了一种更通用的方式为不同平台编译
RustSBI 固件, 既然都读到这儿了, 我们还是自己编译一下吧.

从现在开始, 我就不提供具体指令了.

将 rustsbi 仓库克隆下来之后,
配置好环境,
直接运行 cargo prototyper 应该就可以成功了.

我们可以看到 target/config.toml 中有一些配置信息:
\begin{lstlisting}
num_hart_max = 8
stack_size_per_hart = 16384 # 16 * 1024
heap_size = 1048576 # 1024 * 1024
page_size = 4096
log_level = "INFO"
jump_address = 0x80200000
tlb_flush_limit = 16384 # page_size * 4

[[next_addr]]
start = 0x80000000
end = 0x90000000
\end{lstlisting}



%% 编译 rustsbi

%% 使用 qemu 运行 rustsbi 并测试

%% 修改链接脚本并加载内核

运行
\begin{lstlisting}
qemu-system-riscv64 \                                                                                    13s
    -machine virt \
    -nographic \
    -bios ../loader/rustsbi-prototyper-dynamic.bin \
    -kernel target/riscv64gc-unknown-none-elf/debug/os \
    -S -s
\end{lstlisting}

gdb:
\begin{lstlisting}
riscv64-linux-gnu-gdb \
    -ex 'file target/riscv64gc-unknown-none-elf/debug/os' \
    -ex 'target remote localhost:1234'
\end{lstlisting}

使用 \verb|break _start| 指令可以在 \verb|_start| 的
位置打上断点, 再使用
\verb|continue| 就可以看到我们的程序停在了我们写好的
\verb|loop{}| 中了.


%% 让内核使用 rustsbi 的服务

现在我们就可以开始准备使用 rustsbi 的服务了.

关于 sbi 的 abi, 在 \href{https://github.com/riscv-non-isa/riscv-sbi-doc}
{SBI(Supervisor Binary Interface) 规范} 中可以找到,
这里简单地介绍一下.

rustsbi 运行在机器特权级(machine-mode),
而我们的操作系统运行在监督特权级(supervisor-mode),
在我们需要 sbi 服务的时候,
我们会先将一系列参数放入指定的寄存器,
然后通过 \verb|ecall| 指令来唤起 rustsbi,
跳转到 rustsbi 提前设定好的处理程序.

简要介绍一下 sbi 规范:
sbi 使用 a0-a7 八个寄存器,
调用时可能用到所有的寄存器,
返回时只用到 a0, a1 两个寄存器,
且除了 a0, a1 两个寄存器,
其它所有寄存器的值在调用前后保证不变.

调用时, a7 寄存器指定 SBI 扩展 ID (EID),
a6 寄存器存放 SBI 功能 ID(FID)
(sbi有数个扩展, 一个扩展有若干功能),
a0-a5 是调用参数.
返回时, a0 返回 error code, a1 返回实际数据.

那么我们可以开始试着调用 sbi 了.

\begin{lstlisting}[language=rust]
#[repr(C)]
struct SbiRet {
    /// Error code (0 = success, negative = error)
    error: isize,
    /// Return value or error-specific value
    value: usize,
}

fn sbi_call(
    eid: usize,    // Extension ID (a7)
    fid: usize,    // Function ID (a6)
    arg0: usize,   // Argument 0 (a0)
    arg1: usize,   // Argument 1 (a1)
    arg2: usize,   // Argument 2 (a2)
    arg3: usize,   // Argument 3 (a3)
    arg4: usize,   // Argument 4 (a4)
    arg5: usize,   // Argument 5 (a5)
) -> SbiRet {
    let error;
    let value;
    unsafe {
        core::arch::asm!(
            "ecall",
            inlateout("a0") arg0 => error,
            inlateout("a1") arg1 => value,
            in("a2") arg2,
            in("a3") arg3,
            in("a4") arg4,
            in("a5") arg5,
            in("a6") fid,
            in("a7") eid,
        );
    }
    SbiRet { error, value }
}
\end{lstlisting}
这里的 \verb|#[repr(C)]| 表示
其它的代码很简单, 就是刚才的 sbi 协议的一部分,
就不解释了.

同样, 查阅文档可以得到:
\begin{lstlisting}
pub fn console_putchar(c: usize) {
    sbi_call(1, 0, c, 0, 0, 0, 0, 0);
}
\end{lstlisting}
顺便说一句, 这里的 Console Putchar 只有 EID,
没有 FID, 这应该是历史遗留问题导致的.

\customhrule{}

%% 初始化 sp
接下来我们继续运行,
会发现一个比较蛋疼的问题.

此时 \verb|b _start| 会发现断点打在了 \verb|0x80200008|
而非之前的 \verb|0x80200000|, 然后我们的程序会在运行到
\verb|0x80200008| 之前的 \verb|sd| 指令的时候卡死.

之所以说比较蛋疼是因为之前我们单独运行 \verb|loop{}|
的时候编译并没有出现 \verb|0x80200008| 之前的那些代码,
于是我们现在被迫在没有确认上一步是否正确的时候就要处理新的问题.

首先来说说 \verb|0x80200000| 到 \verb|0x80200008|
之间的这段指令.
这段指令叫做
\href{https://en.wikipedia.org/wiki/Function_prologue_and_epilogue}{函数序言(function prologue)}
简单来说就是为了保存调用函数的

\verb|sd| 指令是


%% 使用打包好的库

%% 给出软件版本





\end{document}
